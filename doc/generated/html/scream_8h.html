<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>screamer: scream.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>scream.h File Reference</h1>UDP flooding program.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;pthread.h&gt;</code><br>
<code>#include &lt;netinet/in.h&gt;</code><br>
<code>#include &quot;<a class="el" href="scream-common_8h-source.html">scream-common.h</a>&quot;</code><br>

<p>
<a href="scream_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscream__base__data__s.html">scream_base_data_s</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__record.html">channel_record</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__db.html">channel_db</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomm__channel.html">comm_channel</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmanager__data.html">manager_data</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#58533720e892db49ea11e202aec9c845">REGISTER_TIMEOUT</a>&nbsp;&nbsp;&nbsp;1000000ULL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#d9af1484f63e43ae0a7383de66a23fdc">REGISTER_REPETITION</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#51bf649eb4bb2e62b4373eb1ffe22538">RESET_TIMEOUT</a>&nbsp;&nbsp;&nbsp;REGISTER_TIMEOUT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#0e0076d59f8358f3439ac6cdc424df99">RESET_REPETITION</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#6e1827b9a8b9eade2d032833824f4420">RETURN_ROUTABILITY_CHECK_TIMEOUT</a>&nbsp;&nbsp;&nbsp;REGISTER_TIMEOUT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#18ba60eb0319e14f0de122fdade8ce05">RETURN_ROUTABILITY_CHECK_REPETITION</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#e6dbd86d2610900142e5c53dce0ecda2">UPDATE_ADDRESS_TIMEOUT</a>&nbsp;&nbsp;&nbsp;REGISTER_TIMEOUT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#c58d3180873352214d4f4c86035e3e16">UPDATE_ADDRESS_REPETITION</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#ff619a3d5c19c2e1536adb8c86287db1">MANAGER_POOL_RATE</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="structscream__base__data__s.html">scream_base_data_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#ab54582139f36bd97eb5dfa6a1061180">scream_base_data</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#eec3a3ebf61424eac751a326ee5aac34">scream_init</a> (<a class="el" href="structscream__base__data__s.html">scream_base_data</a> *state)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#af4fab7ef8b8ea084d4afa44ff91c959">scream_set_dest</a> (<a class="el" href="structscream__base__data__s.html">scream_base_data</a> *state, const char *host_name, uint16_t port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#d22ac272d73ebbe5771253d572baad7a">scream_register</a> (<a class="el" href="structscream__base__data__s.html">scream_base_data</a> *state, unsigned long long sleep_time, int iterations)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#5a17f283d1fe502122da60ba0717a595">scream_pause_loop</a> (<a class="el" href="structscream__base__data__s.html">scream_base_data</a> *state, int sleep_time, size_t flood_size, int iterations, <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1">bool</a> test_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#34051d7850a1e6b73c9678ee6894a06a">scream_send</a> (int sock, pthread_mutex_t *sock_lock, const struct sockaddr_in *dest_addr, const void *buffer, size_t buffer_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#25374080bbaacbf4bfdd3d8cd52b6c1b">scream_send_no_lock</a> (int sock, const struct sockaddr_in *dest_addr, const void *buffer, size_t buffer_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#cc876e770ff7fa91e397b380bb89b168">scream_recv</a> (int sock, pthread_mutex_t *sock_lock, const struct sockaddr_in *dest_addr, void *buffer, size_t buffer_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#63c3ccd6d54469759c6d01a6830cd66c">scream_recv_no_lock</a> (int sock, const struct sockaddr_in *dest_addr, void *buffer, size_t buffer_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#05efd77a069c837ee251c13e1af84a07">scream_send_and_wait_for</a> (const void *send_what, size_t send_what_len, <a class="el" href="structscream__packet__general.html">scream_packet_general</a> *wait_for_what, size_t wait_for_what_len, const char *wait_msg, int sock, pthread_mutex_t *sock_lock, const struct sockaddr_in *dest_addr, const struct timeval *timeout, int repetition)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#75eeb2c061c7a8a0c5e53d7e96fb73cd">scream_send_and_wait_for_no_lock</a> (const void *send_what, size_t send_what_len, <a class="el" href="structscream__packet__general.html">scream_packet_general</a> *wait_for_what, size_t wait_for_what_len, const char *wait_msg, int sock, const struct sockaddr_in *dest_addr, const struct timeval *timeout, int repetition)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#a063fa51983d3f88209da221fbe644bb">scream_reset</a> (<a class="el" href="structscream__base__data__s.html">scream_base_data</a> *state, <a class="el" href="structscream__packet__result.html">scream_packet_result</a> *result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#54af8d7d85e556d886651499c9a0a691">print_result</a> (const <a class="el" href="structscream__packet__result.html">scream_packet_result</a> *result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#d536693281d0b1db043653ecbea1c948">store_db_record</a> (struct <a class="el" href="structchannel__record.html">channel_record</a> *rec, struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#d3e9ab1536bf54dbae984aca5f6588dc">remove_db_record</a> (struct <a class="el" href="structchannel__record.html">channel_record</a> *rec, struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#cda606a9ba48c215457655d536fc29a1">get_channel_by_name</a> (const char *name, const struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#f228e0e8c8d74f71776c2976d3445708">probe_ifs</a> (struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#8aeea7ac1e66bf026981fb6aa07df3e0">check_return_routability</a> (const struct sockaddr_in *dest_addr, const struct <a class="el" href="structchannel__db.html">channel_db</a> *db, const struct <a class="el" href="structcomm__channel.html">comm_channel</a> *main_channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#88870ef3df0850a32d734f10d1075769">get_address</a> (int sock, struct sockaddr_in *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#4767dae6c1a61d0ba57daaa6c85aa868">update_address</a> (int sock, uint32_t id, const struct sockaddr_in *new_addr, const struct sockaddr_in *dest_addr, const struct <a class="el" href="structcomm__channel.html">comm_channel</a> *main_channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#fc31114b8cd2a168b6f761f94e20ab5c">remove_expired_channels</a> (struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#1aafd30b593238d426b97765a41723c2">free_channel</a> (struct <a class="el" href="structchannel__record.html">channel_record</a> *channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#14753538f529819af86d579d9f362268">free_channel_db</a> (struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#c675230e8abbb49e4a161b8e85103c9d">switch_comm_channel</a> (struct <a class="el" href="structcomm__channel.html">comm_channel</a> *main_channel, struct <a class="el" href="structchannel__record.html">channel_record</a> *new_channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#938757f9e214e7d8600e986ca935b0f4">switch_comm_channel_no_lock</a> (struct <a class="el" href="structcomm__channel.html">comm_channel</a> *main_channel, struct <a class="el" href="structchannel__record.html">channel_record</a> *new_channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#baa91798b5e9d942b83ef7275af0d37f">reset_new_and_modified_flags</a> (struct <a class="el" href="structchannel__db.html">channel_db</a> *db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#eb9c38d00438cff5657837f1cfe488aa">start_manager</a> (<a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1">bool</a> is_careful, const char *manager_name, struct <a class="el" href="structmanager__data.html">manager_data</a> *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#eff638a53974e8e3f584ce419feaa116">start_careful_manager</a> (void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="scream_8h.html#b461d1070926f80a1070ce7eba3448ee">start_sloppy_manager</a> (void *data)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
UDP flooding program. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Tobias Heer &lt;<a href="mailto:heer@cs.rwth-aachen.de">heer@cs.rwth-aachen.de</a>&gt; <p>
Tadeus Prastowo &lt;<a href="mailto:eus@member.fsf.org">eus@member.fsf.org</a>&gt;</dd></dl>
This file provides the base functions for the UDP flooder screamer. <hr><h2>Define Documentation</h2>
<a class="anchor" name="ff619a3d5c19c2e1536adb8c86287db1"></a><!-- doxytag: member="scream.h::MANAGER_POOL_RATE" ref="ff619a3d5c19c2e1536adb8c86287db1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MANAGER_POOL_RATE&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The frequency in second of checking for an interface update that a manager thread should perform. 
</div>
</div><p>
<a class="anchor" name="d9af1484f63e43ae0a7383de66a23fdc"></a><!-- doxytag: member="scream.h::REGISTER_REPETITION" ref="d9af1484f63e43ae0a7383de66a23fdc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGISTER_REPETITION&nbsp;&nbsp;&nbsp;(-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of repetitions of send-recv cycle to receive <a class="el" href="scream-common_8h.html#7cc743b2e855728376994cf597f4e033">scream_packet_ack</a>. 
</div>
</div><p>
<a class="anchor" name="58533720e892db49ea11e202aec9c845"></a><!-- doxytag: member="scream.h::REGISTER_TIMEOUT" ref="58533720e892db49ea11e202aec9c845" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGISTER_TIMEOUT&nbsp;&nbsp;&nbsp;1000000ULL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The timeout in microsecond for receiving <a class="el" href="scream-common_8h.html#7cc743b2e855728376994cf597f4e033">scream_packet_ack</a> after sending <a class="el" href="structscream__packet__register.html">scream_packet_register</a>. 
</div>
</div><p>
<a class="anchor" name="0e0076d59f8358f3439ac6cdc424df99"></a><!-- doxytag: member="scream.h::RESET_REPETITION" ref="0e0076d59f8358f3439ac6cdc424df99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESET_REPETITION&nbsp;&nbsp;&nbsp;(-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of repetitions of send-recv cycle to receive <a class="el" href="structscream__packet__result.html">scream_packet_result</a>. 
</div>
</div><p>
<a class="anchor" name="51bf649eb4bb2e62b4373eb1ffe22538"></a><!-- doxytag: member="scream.h::RESET_TIMEOUT" ref="51bf649eb4bb2e62b4373eb1ffe22538" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESET_TIMEOUT&nbsp;&nbsp;&nbsp;REGISTER_TIMEOUT          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The timeout in microsecond for receiving for receiving <a class="el" href="structscream__packet__result.html">scream_packet_result</a> after sending <a class="el" href="scream-common_8h.html#471042ee689451a99118086cbfe07eb1">scream_packet_reset</a>. 
</div>
</div><p>
<a class="anchor" name="18ba60eb0319e14f0de122fdade8ce05"></a><!-- doxytag: member="scream.h::RETURN_ROUTABILITY_CHECK_REPETITION" ref="18ba60eb0319e14f0de122fdade8ce05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETURN_ROUTABILITY_CHECK_REPETITION&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of repetitions of send-recv cycle to receive <a class="el" href="scream-common_8h.html#61f295a7919e518232e95ca66fb2dce9">scream_packet_return_routability_ack</a>. 
</div>
</div><p>
<a class="anchor" name="6e1827b9a8b9eade2d032833824f4420"></a><!-- doxytag: member="scream.h::RETURN_ROUTABILITY_CHECK_TIMEOUT" ref="6e1827b9a8b9eade2d032833824f4420" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETURN_ROUTABILITY_CHECK_TIMEOUT&nbsp;&nbsp;&nbsp;REGISTER_TIMEOUT          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The timeout in microsecond for receiving <a class="el" href="scream-common_8h.html#61f295a7919e518232e95ca66fb2dce9">scream_packet_return_routability_ack</a> after sending <a class="el" href="scream-common_8h.html#db62cb8097e822f1aea1342304649745">scream_packet_return_routability</a>. 
</div>
</div><p>
<a class="anchor" name="c58d3180873352214d4f4c86035e3e16"></a><!-- doxytag: member="scream.h::UPDATE_ADDRESS_REPETITION" ref="c58d3180873352214d4f4c86035e3e16" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPDATE_ADDRESS_REPETITION&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of repetitions of send-recv cycle to receive <a class="el" href="scream-common_8h.html#da060a2cc64bea57f908de7d62d35653">scream_packet_update_address_ack</a>. 
</div>
</div><p>
<a class="anchor" name="e6dbd86d2610900142e5c53dce0ecda2"></a><!-- doxytag: member="scream.h::UPDATE_ADDRESS_TIMEOUT" ref="e6dbd86d2610900142e5c53dce0ecda2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPDATE_ADDRESS_TIMEOUT&nbsp;&nbsp;&nbsp;REGISTER_TIMEOUT          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The timeout in microsecond for receiving <a class="el" href="scream-common_8h.html#da060a2cc64bea57f908de7d62d35653">scream_packet_update_address_ack</a> after sending <a class="el" href="structscream__packet__update__address.html">scream_packet_update_address</a>. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ab54582139f36bd97eb5dfa6a1061180"></a><!-- doxytag: member="scream.h::scream_base_data" ref="ab54582139f36bd97eb5dfa6a1061180" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structscream__base__data__s.html">scream_base_data_s</a> <a class="el" href="structscream__base__data__s.html">scream_base_data</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opaque type for <a class="el" href="structscream__base__data__s.html">scream_base_data_s</a>. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8aeea7ac1e66bf026981fb6aa07df3e0"></a><!-- doxytag: member="scream.h::check_return_routability" ref="8aeea7ac1e66bf026981fb6aa07df3e0" args="(const struct sockaddr_in *dest_addr, const struct channel_db *db, const struct comm_channel *main_channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structchannel__record.html">channel_record</a>* check_return_routability           </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcomm__channel.html">comm_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>main_channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check all possible communication channels by binding all non-expired addresses in the DB to sockets stored in the corresponding records in the DB. The <a class="el" href="structchannel__record.html#d0df78bb31721664a695c282267ede8d">channel_record::is_connected</a> field of all records whose sockets can be used to contact the listener is set to <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a82764c3079aea4e60c80e45befbb839">bool::TRUE</a>, while that of other records is set to <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a1e095cc966dbecf6a0d8aad75348d1a">bool::FALSE</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the address of the listener. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>all of the possible communication channels whose <a class="el" href="structchannel__record.html#d0df78bb31721664a695c282267ede8d">channel_record::is_connected</a> is to be updated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>main_channel</em>&nbsp;</td><td>the main channel of communication.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The best communication channel based on checking time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1aafd30b593238d426b97765a41723c2"></a><!-- doxytag: member="scream.h::free_channel" ref="1aafd30b593238d426b97765a41723c2" args="(struct channel_record *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_channel           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a channel record.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>the channel to be freed (no longer valid upon return). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="14753538f529819af86d579d9f362268"></a><!-- doxytag: member="scream.h::free_channel_db" ref="14753538f529819af86d579d9f362268" args="(struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_channel_db           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove and free all channels in the DB.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>the DB whose channels are to be removed and freed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="88870ef3df0850a32d734f10d1075769"></a><!-- doxytag: member="scream.h::get_address" ref="88870ef3df0850a32d734f10d1075769" args="(int sock, struct sockaddr_in *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> get_address           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the name of a socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket whose name is to be retrieved. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>the retrieved name of the socket.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385270e6bc5763f61154abf4f4af205ce2c3">err_code::SC_ERR_NAME</a> if there is a problem in retrieving the name or <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385219dc71e309cc0668f345b072e6ac2761">err_code::SC_ERR_SUCCESS</a> if everything is okay. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cda606a9ba48c215457655d536fc29a1"></a><!-- doxytag: member="scream.h::get_channel_by_name" ref="cda606a9ba48c215457655d536fc29a1" args="(const char *name, const struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structchannel__record.html">channel_record</a>* get_channel_by_name           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a channel record from that has the specified name from the DB.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the channel record to find. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>a collection of channel records.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL if the name matches no record or a <a class="el" href="structchannel__record.html">channel_record</a> having the specified name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54af8d7d85e556d886651499c9a0a691"></a><!-- doxytag: member="scream.h::print_result" ref="54af8d7d85e556d886651499c9a0a691" args="(const scream_packet_result *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_result           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structscream__packet__result.html">scream_packet_result</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the statistics of screaming.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>the result received from the server. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f228e0e8c8d74f71776c2976d3445708"></a><!-- doxytag: member="scream.h::probe_ifs" ref="f228e0e8c8d74f71776c2976d3445708" args="(struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1">bool</a> probe_ifs           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check for an update in the available communication channels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>the collection of available communication channels to be updated. Which record is new and which one is updated can be checked through <a class="el" href="structchannel__record.html#59ac19d5ed02c78c2c068931215a7c13">channel_record::is_new</a>, <a class="el" href="structchannel__record.html#06b9f6cbdc2b461ab81ba0e51a02ab18">channel_record::is_expired</a> and <a class="el" href="structchannel__record.html#2b224291975d40f308268c1c3ecfa83c">channel_record::is_modified</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a82764c3079aea4e60c80e45befbb839">bool::TRUE</a> if there is an update or <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a1e095cc966dbecf6a0d8aad75348d1a">bool::FALSE</a> if there is none. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3e9ab1536bf54dbae984aca5f6588dc"></a><!-- doxytag: member="scream.h::remove_db_record" ref="d3e9ab1536bf54dbae984aca5f6588dc" args="(struct channel_record *rec, struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_db_record           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td>
          <td class="paramname"> <em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a channel record from the DB. The removed channel still has its <a class="el" href="structchannel__record.html#27e815045f2a072b4c4a88950792968c">channel_record::next</a> and <a class="el" href="structchannel__record.html#6a213af6dde660a958dbff87d55d4a01">channel_record::prev</a> pointers points to the records in the DB so that it is save to invoke this function while iterating over the DB.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rec</em>&nbsp;</td><td>the record to be removed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>the DB from which the record is to be removed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc31114b8cd2a168b6f761f94e20ab5c"></a><!-- doxytag: member="scream.h::remove_expired_channels" ref="fc31114b8cd2a168b6f761f94e20ab5c" args="(struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_expired_channels           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All expired channels in the DB are removed and freed accordingly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>the DB whose expired channels are to be removed and freed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="baa91798b5e9d942b83ef7275af0d37f"></a><!-- doxytag: member="scream.h::reset_new_and_modified_flags" ref="baa91798b5e9d942b83ef7275af0d37f" args="(struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_new_and_modified_flags           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <a class="el" href="structchannel__record.html#59ac19d5ed02c78c2c068931215a7c13">channel_record::is_new</a> and <a class="el" href="structchannel__record.html#2b224291975d40f308268c1c3ecfa83c">channel_record::is_modified</a> to <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a1e095cc966dbecf6a0d8aad75348d1a">bool::FALSE</a>. This should be performed after a call to <a class="el" href="scream_8h.html#f228e0e8c8d74f71776c2976d3445708">probe_ifs()</a> that usually is followed by a call to <a class="el" href="scream_8h.html#8aeea7ac1e66bf026981fb6aa07df3e0">check_return_routability()</a> and usually is followed by some operations that use those flags to make some decisions. Those flags need to be reset because after all operations is done, the flagged records are no longer new or modified when they are passed to another call to <a class="el" href="scream_8h.html#f228e0e8c8d74f71776c2976d3445708">probe_ifs()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>the collection of available communication channels to be updated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eec3a3ebf61424eac751a326ee5aac34"></a><!-- doxytag: member="scream.h::scream_init" ref="eec3a3ebf61424eac751a326ee5aac34" args="(scream_base_data *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscream__base__data__s.html">scream_base_data</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the memory of a <a class="el" href="scream_8h.html#ab54582139f36bd97eb5dfa6a1061180">scream_base_data</a> and the internal program state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>basic connection state information of a screamer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a17f283d1fe502122da60ba0717a595"></a><!-- doxytag: member="scream.h::scream_pause_loop" ref="5a17f283d1fe502122da60ba0717a595" args="(scream_base_data *state, int sleep_time, size_t flood_size, int iterations, bool test_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_pause_loop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscream__base__data__s.html">scream_base_data</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sleep_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>flood_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1">bool</a>&nbsp;</td>
          <td class="paramname"> <em>test_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loop, generate FLOOD data and send FLOOD data to destination.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>basic connection state information of a screamer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sleep_time</em>&nbsp;</td><td>delay between loops (in microseconds). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flood_size</em>&nbsp;</td><td>size of the FLOOD data to generate (in bytes). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterations</em>&nbsp;</td><td>the number of loops (0 means infinite loops). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>test_mode</em>&nbsp;</td><td>activate an intentional packet drop and reordering to test the listener.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc876e770ff7fa91e397b380bb89b168"></a><!-- doxytag: member="scream.h::scream_recv" ref="cc876e770ff7fa91e397b380bb89b168" args="(int sock, pthread_mutex_t *sock_lock, const struct sockaddr_in *dest_addr, void *buffer, size_t buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_recv           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>sock_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a UDP packet from the source specified in <a class="el" href="structscream__base__data__s.html#12793818beb8f6b54412a5c1b9a4e239">scream_base_data::dest_addr</a> through <a class="el" href="structscream__base__data__s.html#11232a2c8a0bb4e996e252e70699479d">scream_base_data::sock</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket from which the data is to be received. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock_lock</em>&nbsp;</td><td>the concurrent modification guard of the socket. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the address from which the data is to be received. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>the buffer to receive data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>the size of the buffer in bytes.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385246020c107315da22e68016ad58c6dd06">err_code::SC_ERR_COMM</a> if no packet is received until timeout, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852d087ba0f469a35f657f4b94f1c3012c2">err_code::SC_ERR_WRONGSENDER</a> if the packet is not received from the specified source, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f38521f889961d4531447810a4c0e6c37eeac">err_code::SC_ERR_PACKET</a> if the packet is not a scream packet, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385219dc71e309cc0668f345b072e6ac2761">err_code::SC_ERR_SUCCESS</a> if the packet is received from the specified source before timeout, or else <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f38520b5d02d416f496c2cf9e6973b1bff670">err_code::SC_ERR_RECV</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63c3ccd6d54469759c6d01a6830cd66c"></a><!-- doxytag: member="scream.h::scream_recv_no_lock" ref="63c3ccd6d54469759c6d01a6830cd66c" args="(int sock, const struct sockaddr_in *dest_addr, void *buffer, size_t buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_recv_no_lock           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a UDP packet from the specified address through the given socket without locking the socket first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket from which the packet is received. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>from which address the packet must be received. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>the buffer to receive data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>the size of the buffer in bytes.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385246020c107315da22e68016ad58c6dd06">err_code::SC_ERR_COMM</a> if no packet is received until timeout, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852d087ba0f469a35f657f4b94f1c3012c2">err_code::SC_ERR_WRONGSENDER</a> if the packet is not received from the specified source, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f38521f889961d4531447810a4c0e6c37eeac">err_code::SC_ERR_PACKET</a> if the packet is not a scream packet, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385219dc71e309cc0668f345b072e6ac2761">err_code::SC_ERR_SUCCESS</a> if the packet is received from the specified source before timeout, or else <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f38520b5d02d416f496c2cf9e6973b1bff670">err_code::SC_ERR_RECV</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d22ac272d73ebbe5771253d572baad7a"></a><!-- doxytag: member="scream.h::scream_register" ref="d22ac272d73ebbe5771253d572baad7a" args="(scream_base_data *state, unsigned long long sleep_time, int iterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_register           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscream__base__data__s.html">scream_base_data</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>sleep_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iterations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a <a class="el" href="scream-common_8h.html#23fe7074617d7bc1e353028f745e6f7a9580add8a015d5ffb2b5a8d10ec9524f">scream_packet_type::SC_PACKET_REGISTER</a> packet to the destination. This will block until the registration is successful as indicated by receiving a <a class="el" href="scream-common_8h.html#23fe7074617d7bc1e353028f745e6f7ac7d6d9598bfe4c6c384d888d6f289cd9">scream_packet_type::SC_PACKET_ACK</a> packet.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>basic connection state information of a screamer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sleep_time</em>&nbsp;</td><td>the delay between sends in microsecond. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterations</em>&nbsp;</td><td>the number of <a class="el" href="scream-common_8h.html#23fe7074617d7bc1e353028f745e6f7ab58fe7b07032df962e2884078c59248d">scream_packet_type::SC_PACKET_FLOOD</a> packets to be sent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a063fa51983d3f88209da221fbe644bb"></a><!-- doxytag: member="scream.h::scream_reset" ref="a063fa51983d3f88209da221fbe644bb" args="(scream_base_data *state, scream_packet_result *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscream__base__data__s.html">scream_base_data</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscream__packet__result.html">scream_packet_result</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a <a class="el" href="scream-common_8h.html#23fe7074617d7bc1e353028f745e6f7a9a4300c78e82fab76c741de391d3c74a">scream_packet_type::SC_PACKET_RESET</a> packet to the destination. This will block until a reset is successful as indicated by receiving a <a class="el" href="scream-common_8h.html#23fe7074617d7bc1e353028f745e6f7a516b0f1d973c7b999c68648a4baf6e9d">scream_packet_type::SC_PACKET_RESULT</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>basic connection state information of a screamer. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>the result sent back by the server.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="34051d7850a1e6b73c9678ee6894a06a"></a><!-- doxytag: member="scream.h::scream_send" ref="34051d7850a1e6b73c9678ee6894a06a" args="(int sock, pthread_mutex_t *sock_lock, const struct sockaddr_in *dest_addr, const void *buffer, size_t buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_send           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>sock_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a UDP packet to the destination specified in the destination address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket to send the data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock_lock</em>&nbsp;</td><td>the concurrent modification guard of the socket. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the destination address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>data to be sent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>the size of the buffer in bytes.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="05efd77a069c837ee251c13e1af84a07"></a><!-- doxytag: member="scream.h::scream_send_and_wait_for" ref="05efd77a069c837ee251c13e1af84a07" args="(const void *send_what, size_t send_what_len, scream_packet_general *wait_for_what, size_t wait_for_what_len, const char *wait_msg, int sock, pthread_mutex_t *sock_lock, const struct sockaddr_in *dest_addr, const struct timeval *timeout, int repetition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_send_and_wait_for           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>send_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>send_what_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscream__packet__general.html">scream_packet_general</a> *&nbsp;</td>
          <td class="paramname"> <em>wait_for_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>wait_for_what_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>wait_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>sock_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>repetition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keep resending a particular message to the destination specified in <a class="el" href="structscream__base__data__s.html#12793818beb8f6b54412a5c1b9a4e239">scream_base_data::dest_addr</a> through <a class="el" href="structscream__base__data__s.html#11232a2c8a0bb4e996e252e70699479d">scream_base_data::sock</a> every time a timeout happens until a particular expected message is received from the destination.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>send_what</em>&nbsp;</td><td>the data sent to the destination. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>send_what_len</em>&nbsp;</td><td>the length of the data sent to the destination. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>wait_for_what</em>&nbsp;</td><td>the expected scream packet type must be specified in <a class="el" href="structscream__packet__general.html#09f535722b29e45567ae62788ef596ab">scream_packet_general::type</a> and the received packet will be written to this buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wait_for_what_len</em>&nbsp;</td><td>the actual length of the result buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wait_msg</em>&nbsp;</td><td>the message that should be printed everytime the particular message is sent to the destination. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket through which data are sent and received. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock_lock</em>&nbsp;</td><td>the concurrent modification guard of the socket. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the destination address from which data is received. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>the timeout after which the particular message is resent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>repetition</em>&nbsp;</td><td>how many times the send-recv process has to be repeated if it gets a timeout or a wrong packet (-1 means keep repeating)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385246020c107315da22e68016ad58c6dd06">err_code::SC_ERR_COMM</a> if the send-recv process has been repeated as many as the specified repetition or another error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="75eeb2c061c7a8a0c5e53d7e96fb73cd"></a><!-- doxytag: member="scream.h::scream_send_and_wait_for_no_lock" ref="75eeb2c061c7a8a0c5e53d7e96fb73cd" args="(const void *send_what, size_t send_what_len, scream_packet_general *wait_for_what, size_t wait_for_what_len, const char *wait_msg, int sock, const struct sockaddr_in *dest_addr, const struct timeval *timeout, int repetition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_send_and_wait_for_no_lock           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>send_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>send_what_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscream__packet__general.html">scream_packet_general</a> *&nbsp;</td>
          <td class="paramname"> <em>wait_for_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>wait_for_what_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>wait_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>repetition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keep resending a particular message to the destination specified in the given destination address through the given socket every time a timeout happens or a wrong message is received until a particular expected message is received from the destination without locking the socket first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>send_what</em>&nbsp;</td><td>the data sent to the destination. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>send_what_len</em>&nbsp;</td><td>the length of the data sent to the destination. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>wait_for_what</em>&nbsp;</td><td>the expected scream packet type must be specified in <a class="el" href="structscream__packet__general.html#09f535722b29e45567ae62788ef596ab">scream_packet_general::type</a> and the received packet will be written to this buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wait_for_what_len</em>&nbsp;</td><td>the actual length of the result buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wait_msg</em>&nbsp;</td><td>the message that should be printed everytime the particular message is sent to the destination. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket through which message is exchanged. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the destination address to/from which message is sent/received. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>the timeout after which the particular message is resent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>repetition</em>&nbsp;</td><td>how many times the send-recv process has to be repeated if it gets a timeout or a wrong packet (-1 means keep repeating)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385246020c107315da22e68016ad58c6dd06">err_code::SC_ERR_COMM</a> if the send-recv process has been repeated as many as the specified repetition or another error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="25374080bbaacbf4bfdd3d8cd52b6c1b"></a><!-- doxytag: member="scream.h::scream_send_no_lock" ref="25374080bbaacbf4bfdd3d8cd52b6c1b" args="(int sock, const struct sockaddr_in *dest_addr, const void *buffer, size_t buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_send_no_lock           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a UDP packet through the given socket to the specified destination without locking the socket first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket used to send the packet. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the address to which the packet is to be sent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>data to be sent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>the size of the buffer in bytes.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="af4fab7ef8b8ea084d4afa44ff91c959"></a><!-- doxytag: member="scream.h::scream_set_dest" ref="af4fab7ef8b8ea084d4afa44ff91c959" args="(scream_base_data *state, const char *host_name, uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> scream_set_dest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscream__base__data__s.html">scream_base_data</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve the host name to initialize <a class="el" href="structscream__base__data__s.html#12793818beb8f6b54412a5c1b9a4e239">scream_base_data::dest_addr</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>basic connection state information of a screamer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host_name</em>&nbsp;</td><td>the name of the destination host. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>port</em>&nbsp;</td><td>the destination port number.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eff638a53974e8e3f584ce419feaa116"></a><!-- doxytag: member="scream.h::start_careful_manager" ref="eff638a53974e8e3f584ce419feaa116" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* start_careful_manager           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the manager thread to monitor IPv4 addresses in all available public interfaces (i.e,. ignoring the loopback interface). It can change the communication channel to another one that is more desirable. Spotting an update, this careful manager will prevent anyone from using the communication channel by holding a mutex lock on the channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>a <a class="el" href="structmanager__data.html">manager_data</a> object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL because a manager is not suppossed to quit until program exit. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb9c38d00438cff5657837f1cfe488aa"></a><!-- doxytag: member="scream.h::start_manager" ref="eb9c38d00438cff5657837f1cfe488aa" args="(bool is_careful, const char *manager_name, struct manager_data *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start_manager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1">bool</a>&nbsp;</td>
          <td class="paramname"> <em>is_careful</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>manager_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmanager__data.html">manager_data</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the manager thread to monitor IPv4 addresses in all available public interfaces (i.e,. ignoring the loopback interface). It can change the communication channel to another one that is more desirable<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>is_careful</em>&nbsp;</td><td>will make the manager to behave as per the specification of <a class="el" href="scream_8h.html#eff638a53974e8e3f584ce419feaa116">start_careful_manager()</a> when it is set to <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a82764c3079aea4e60c80e45befbb839">bool::TRUE</a>. When it is set to <a class="el" href="scream-common_8h.html#f6a258d8f3ee5206d682d799316314b1a1e095cc966dbecf6a0d8aad75348d1a">bool::FALSE</a>, it will behave as per the specification of <a class="el" href="scream_8h.html#b461d1070926f80a1070ce7eba3448ee">start_sloppy_manager()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>manager_name</em>&nbsp;</td><td>the name of the manager. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>the needed data to perform a management duty. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b461d1070926f80a1070ce7eba3448ee"></a><!-- doxytag: member="scream.h::start_sloppy_manager" ref="b461d1070926f80a1070ce7eba3448ee" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* start_sloppy_manager           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the manager thread to monitor IPv4 addresses in all available public interfaces (i.e,. ignoring the loopback interface). It can change the communication channel to another one that is more desirable. This sloppy manager will not prevent anyone from using the communication channel upon spotting a need to update the communication channel. The manager will only do so when it is replacing the communication channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>a <a class="el" href="structmanager__data.html">manager_data</a> object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NULL because a manager is not suppossed to quit until program exit. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d536693281d0b1db043653ecbea1c948"></a><!-- doxytag: member="scream.h::store_db_record" ref="d536693281d0b1db043653ecbea1c948" args="(struct channel_record *rec, struct channel_db *db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void store_db_record           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td>
          <td class="paramname"> <em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structchannel__db.html">channel_db</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store a channel record in the DB.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rec</em>&nbsp;</td><td>the record to be stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>the DB in which the record is to be stored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c675230e8abbb49e4a161b8e85103c9d"></a><!-- doxytag: member="scream.h::switch_comm_channel" ref="c675230e8abbb49e4a161b8e85103c9d" args="(struct comm_channel *main_channel, struct channel_record *new_channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> switch_comm_channel           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcomm__channel.html">comm_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>main_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td>
          <td class="paramname"> <em>new_channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace the main communication socket by locking it with its corresponding mutex lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>main_channel</em>&nbsp;</td><td>the main channel of communication to be updated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>new_channel</em>&nbsp;</td><td>the new channel of communication.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="938757f9e214e7d8600e986ca935b0f4"></a><!-- doxytag: member="scream.h::switch_comm_channel_no_lock" ref="938757f9e214e7d8600e986ca935b0f4" args="(struct comm_channel *main_channel, struct channel_record *new_channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> switch_comm_channel_no_lock           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcomm__channel.html">comm_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>main_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structchannel__record.html">channel_record</a> *&nbsp;</td>
          <td class="paramname"> <em>new_channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace the main communication socket without first locking it with its corresponding mutex lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>main_channel</em>&nbsp;</td><td>the main channel of communication to be updated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>new_channel</em>&nbsp;</td><td>the new channel of communication.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4767dae6c1a61d0ba57daaa6c85aa868"></a><!-- doxytag: member="scream.h::update_address" ref="4767dae6c1a61d0ba57daaa6c85aa868" args="(int sock, uint32_t id, const struct sockaddr_in *new_addr, const struct sockaddr_in *dest_addr, const struct comm_channel *main_channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f3852">err_code</a> update_address           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>new_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcomm__channel.html">comm_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>main_channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inform the listener of this screamer's new address so that when the screamer sends packet from this new address, the listener knows whose book-keeping record it should update.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket through which the update notification is delivered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>the ID of the client so that the listener can identify which old address needs to be updated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>new_addr</em>&nbsp;</td><td>the new address of the client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest_addr</em>&nbsp;</td><td>the address of the listener. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>main_channel</em>&nbsp;</td><td>the main communication channel.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385246020c107315da22e68016ad58c6dd06">err_code::SC_ERR_COMM</a> if the process of updating an address fails because the listener does not send acknowledgement, <a class="el" href="scream-common_8h.html#08b18ac8af0f3462354240d9732f385219dc71e309cc0668f345b072e6ac2761">err_code::SC_ERR_SUCCESS</a> if the update process completes successfully or another error code in case there is a problem with the socket. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 25 04:18:49 2009 for screamer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
